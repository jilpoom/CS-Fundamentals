#include <stdio.h>

/*
    Shift Operations
    1. 시프트 연산은 사칙 연산보다 낮은 우선 순위를 갖는다.
      - 1 << 2 + 3 << 4 == 1 << (2 + 3) << 4
    2. 우측 시프트 연산(>>)은 두 가지로 나누어진다.
      - 논리적 연산(0을 채우며, 이동)
        - 0110 0011 >> 4 == 0000 0110
      - 산술적 연산 (MSB(최상위 비트)를 채우며, 이동)
        - 0110 0011 >> 4 == 0000 0110
    3. 만약, 비트 w 보다 큰 k인 값을 시프트 하게된다면, k % w 만큼 이동한다(나머지 연산)
      - 컴파일 시, 컴파일러에서 `right shift count >= width of type` 이라는 경고를 준다.
*/


int main(void)
{
    int x = 123;
    
    printf("%d, 0x%08x\n", x << 2, x << 2); // 492, 0x000001EC
    printf("%d, 0x%08x\n", x >> 2, x >> 2); // 30, 0x0000001E
    printf("%d, 0x%08x\n", x >> 32, x >> 32); // 123, 0x0000007B
}