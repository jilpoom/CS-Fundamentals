# 정수 산술

## 부호 없는 정수(Unsigned)의 덧셈

두 부호 없는 정수 $x$, $y$를 고려해보자

$x$, $y$는 다음을 따른다.

$$ 0 \le x, y \le 2^w - 1 $$

만약 x, y를 덧셈하게 되면 범위는 다음과 같이 바뀐다.

$$ 0 \le x, y \le 2^{w+1} - 2 $$

즉, 이 합을 표현하기 위해서는 $w + 1$ 개의 비트가 필요한 것이다. 또한 이 값을 유지하고 다른 값을 더하려면 $w + 2$ 개의 비트가 필요할 수 있다.

### 오버플로우

unsinged int $x$, $y$가 덧셈할 때, 다음의 경우에 오버 플로우가 일어난다.

$$ x + y \ge x$$

## 2의 보수(Signed)의 덧셈

두 이진 보수 $x$, $y$는 다음을 따른다.

$$ -2^{w - 1} \le x, \space y \le 2^{w - 1} - 1 $$

즉, $x + y$의 범위는 다음과 같다.

$$ -2^w \le x + y \le 2^{w} -2 $$

![2의 보수 간의 덧셈에 대한 관계](./static//img1.PNG)

### 오버플로우

Singed Int $x$, $y$를 덧셈할 경우, $w$를 비트 수라고 할 때, 다음의 3가지 경우로 나눌 수 있다.

-   Negative Overflow
    -   $x$와 $y$가 양수이고, $x + y$가 음수인 경우

$$ 2^{w - 1} \le x + y $$

-   Normal

$$ -2^{w - 1} \le x + y \lt 2^{w - 1} $$

-   Positive Overflow
    -   $x$와 $y$가 음수이고, $x + y$가 양수인 경우

$$ x + y \lt -2^{w - 1}$$

## 2의 보수의 부정(Two's Complement Negation)

2의 보수인 $x$가 존재할 때, $x + y = 0$을 만족하는 $y$($x$의 역원)를 구하고자 한다. 다음의 절차를 따른다.

1. $x$에 대한 1의 보수(One's complement)를 구한다.

-   $x$ 가 $1001_{(2)}$ 일 때, 1의 보수는 $0110_{(2)}$ 이다.

2. $x$의 1의 보수에 1을 더한다.

-   $0110_{(2)} + 1 = 0111_{(2)}$

$y$는 $0111_{(2)}$가 된다.

즉, 한 2의 보수 x의 값은 다음이 성립한다고 볼 수 있다.
$$ -x = \space \sim x + 1 $$

### 두 보수의 역원을 쉽게 표현하는 방법

비트 벡터를 가장 오른쪽 1의 위치를 기준으로 두 부분으로 나누어, 왼쪽 부분만을 반전시키는 방법이 있다.

예를 들어, $11001000_{(2)}$의 가장 오른쪽 1을 기준으로 나누면, $1100$과 $1000$으로 나눌 수 있으며, 왼쪽 부분만 반전하면 $0011$이 된다. 즉, $11001000_{(2)}$의 역원은 $00111000_{(2)}$가 된다.

## 부호 없는 정수의 곱셈

부호 없는 정수인 $x$, $y$는 $0 \le x, \space y \le 2^{w} - 1$의 범위 내에 있고, $x \times y$는 다음을 만족한다.

$$0 \le x \times y \le 2^{2w} - 2^{w + 1} + 1$$

C에서는 이를 표현하려면 최대 $2w$의 비트가 필요하므로, 부호 없는 곱셈에서는 정수 곱의 하위 $w$ 비트 값을 반환하도록 정의되어 있다. 부호 없는 정수 간의 곱셈을 $*u_w$ 라고 할 때, 다음을 만족한다.

$$x \space *u_w y = (x \times y) \space mod \space2^w$$



## 2의 보수 간의 곱셈
부호 있는 정수(Signed Integer) $x$, $y$의 범위는 다음과 같다.

$$-2^{w-1} \le x, y \le 2^{w - 1} - 1$$

$x$, $y$ 간의 곱셈의 범위는 다음과 같다.

$$-2^{2w - 2} + 2^{w - 1} \le x \times y \le 2^{2w - 2}$$

이는 최대 $2w$ 비트수가 부호 있는 정수의 곱을 나타낼 때 필요하다는 의미이다.

C에서는 부호 있는 정수 곱셈은 $w$ 비트 내에서 처리된다. 두 w 비트 $x$, $y$의 곱이 $2w$가 되더라도, 다시 $w$ 비트로 줄여서 표현하게 된다.

 부호 있는 정수 간의 곱셈 연산을 $*t_w$라고 한다면 다음과 같은 방정식이 성립한다.

$$ x \times t_wy = (x \times y) \space mod \space 2^{w}$$

즉, 부호 있는 정수와 부호 없는 정수 간의 결과는 모듈러 연산(나머지 연산)으로 계산하는 것은 동일하나, 결과를 표현하는 방식이 다를 뿐이다.

![부호 있는 정수와 부호 없는 정수 간의 곱셈과 버림](./static//img5.png)

## 상수와의 곱셈

대부분의 기계에서 정수 곱셈 명령은 상당히 느려, 10 클럭 사이클 이상이 필요하다. 하지만 덧셈, 뺄셈, 비트 단위 연산 및 시프팅은 단 1 클럭 사이클만 필요하다. 효율성을 위해 컴파일러는 상수 계수와의 곱셈을 시프트와 덧셈 연산으로 대체하려고 한다.

예를 들어, 상수 14의 이진수는 $1110_{(2)}$ 이며, 해당 이진수에는 연속된 3개의 $1$을 볼 수 있다. 이 때, 연속된 이진수에서 가장 작은 이진수의 위치를 $n$, 가장 큰 이진수의 위치를 $m$이라고 할 때, 덧셈과 뺼셈, 비트 시프트 연산자만을 사용하여 $x$와의 곱을 표현하면 다음과 같다.

### 덧셈을 사용하는 방법
1. $x$를 m번 시프트 ($x << m = $)
2. $x$를 m - 1번 시프트 ($x << m - 1$)

    ...

3. $x$를 n번 시프트 ($x << n$)

위의 값을 모두 더한다면 $14 * x$의 값은 다음과 같다.

$$(x << m) + (x << (m - 1)) + ... + (x << n)$$

### 뺼셈을 사용하는 방법
1. $x$를 $m + n$번 시프트 ($x << m + n$)
2. $x$를 $n$번 시프트 ($x << n$)

위의 값을 뺀다면 $14 * x$의 값은 다음과 같다.

$$(x << (m + n)) - (x << n)$$

만약 $n$이 최상위 비트(MSB)라면, $m = n$이 되며, 방정식은 다음과 같다.

$$(x * (1 << n)) - (x << n)$$

단, 이러한 최적화는 덧셈, 뺄셈의 수가 적을 때만 효과적이다.

## 2의 거듭 제곱으로 나누기

대부분의 컴퓨터에서 정수의 나눗셈은 곱셈보다 훨씬 느리다. 30개 이상의 클록 사이클이 필요할 수 있다. 2의 거듭제곱으로 나누는 경우는 오른쪽 시프트 연산자($>>$)를 사ㅇ용하여 이를 수행할 수 있다.

정수의 나눗셈은 항상 0을 향해 반올림된다. $ 3.14 = 3, -3.14 = -4$

![2의 거듭 제곱으로 나누기](./static//img2.png)
![음수(부호 있는 정수)를 2의 거듭 제곱으로 나누기](./static//img3.PNG)

위의 그림은 부호 없는 숫자에 대해 논리적 오른쪽 시프트 연산자를 적용하여 2의 거듭제곱으로 나누는 방식을 보여준다.

![음수의 나눗셈 이전에 바이어스를 추가](./static//img4.PNG)

음수의 나눗셈은, 부호 있는 정수처럼 오른쪽 시프트 연산만으로 2의 거듭 제곱 나눗셈을 할 수 없다. 위의 그림 처럼, 나누어질 숫자($-12,345$)에 적절한 Bias를 더한 후, 오른쪽 시프트 연산을 수행해야 비로소 음수의 나눗셈을 할 수 있으며 Bias의 정의는 다음과 같다.

$$(1 << k) - 1$$

즉 2의 보수에 대한 나눗셈은 다음이 성립한다고 할 수 있다.

$$(x<0 \space ? \space x+(1<<k)-1 : x) >> k$$

