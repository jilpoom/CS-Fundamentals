# 부동 소수점

부동 소수점이란, 다음과 같은 형태의 유리수를 인코딩하는 방법이다.

$$V = x \times 2^{y}$$

이는 매우 큰 숫자($V > 0$)와, 작은 숫자($V < 0$), 그리고 실수 연산의 근사치로 사용된다.

1980년대 이후, [IEEE 754](https://ko.wikipedia.org/wiki/IEEE_754) 표준이 부동 소수점 연산의 표준화를 이루어 갔으며, 현재 서로 다른 시스템 간의 호환성을 보장하고 수치적 안정성을 향상시키는데 기여하고 있다.

이 섹션에서는 IEEE 754에서 정의된 부동 소수점 연산 표준을 살펴보며, 숫자가 형식에서 정확하게 표현될 수 없을 때, 발생하는 반올림 문제, 부동 소수점 간의 연산 또한 살펴본다.

## 소수점을 가진 숫자를 이진수로 표현

10의 양의 거듭제곱으로 소수를 가진 실수를 나타낸다면 다음과 같다.

$$12.3410 = 1 \times 10^1 + 2 \times 10^0 + 3 \times 10^{-1} + 4 \times 10^{-2} = \frac {1234}{100}$$

이를 이진 숫자로 나타낸다면 소수부를 가진 실수 $b$를 다음과 같이 정의할 수 있다.

$$b = \sum^{m}_{i = -n} 2 ^i \times b_i$$

아래의 식에서 $.$은 이진 소수점을 나타낸다.

$$101.112 = 1 \times 2^2 + 0 \times 2 ^1 + 1 \times 2^{-1} + 1 \times 2^{-2} = 4 + 0 + 1 + \frac {1}{2} + \frac {1}{4} = \frac {53}{4}$$

위의 표현 방식은 부동 소수점 숫자를 이해하고 구현하는데 중요한 역할을 한다.

![부동 소수점의 이진 표현](./static/figure%202-30.PNG)

### 소수의 이진 표현의 한계

$$b = \sum^{m}_{i = -n} 2 ^i \times b_i$$

위의 방정식에서 알 수 있듯, 소수의 이진 표현은 $x \times 2^{-n}$의 형태의 소수만을 정확하게 나타낼 수 있으며, $\frac {1}{3}$, $\frac {1}{5}$와 같은 소수는 근사치로만 표현할 수 있다.

## IEEE 부동 소수점 표현

IEEE 부동소수점 표준은 숫자를 다음의 형태로 표현한다.

$$V = (-1)^s \times M \times 2^E$$

- $s$: 숫자가 음수($s = 1$) 혹은 양수($s = 0$)인지 결정. 숫자 값 0에 대한 부호 비트 해석은 특별한 경우로 처리된다.
- $M$: 가수, $1$과 $2$ 사이 혹은 $0$과 $1$ 사이의 소수 이진수
- $E$: 2의 지수, 가중치

즉, 부동 소수점 숫자의 비트 표현은 인코딩을 위해 3 가지의 필드로 나누어진다.

- 부호 필드: 부호 비트 $s$를 인코딩
- 지수 필드: $k$ 개의 비트($exp = e_{k-1}...e_1e_0$)로 지수 $E$를 인코딩
- 가수 필드: $n$ 개의 비트($frac = f_{n-1}...f_1f_0$)로 가수 $M$을 인코딩. 단, 인코딩된 값은 지수 필드가 0인지 아닌지에 따라 달라진다.

예를 들어 `float` 타입(단일 정밀도 부동 소수점 형식)에서 필드 $s$, $exp$, $frac$은 각각 $1$, $8$, $23$ 비트이며, 이는 총 $32$ 비트 표현을 제공한다. 마찬가지로, `double` 타입(이중 정밀도 부동 소수점 형식)은 각각 $1$, $11$, $52$ 비트 이며, 이는 총 $64$비트 표현을 제공한다.

### Case 1: Normalized Values(정규화된 숫자)

일반적인 경우, 지수($exp$) 비트 패턴이 모두 0(모든 비트가 0) 혹은 1이 아닌 경우(`float` 255, `double` 2047) 발생한다. 

이 경우의 지수 필드는, **편향(바이어스)된 형태로 표현된 부호 있는 정수로 해석**된다.

$$\begin{align*} &E = e - Bias \\
&e = [e_{k-1}...e_1e_0]_{(2)} \\
&Bias = 2^{k - 1} - 1 
\end{align*}$$


또한, 분수(소수) 필드는 분수값 $f$를 나타내며 다음과 같은 식을 만족한다.

$$\begin{align*}
&0 \le f \lt 1, \\
&f = [0.f_{n-1}f_{n-2}...f_{1}f_{0}]_{(2)} 
\end{align*}$$

**암시된 선행 1 표현**이라는 기법으로, 가수부 $M$은 다음과 같이 선언된다.

$$M = 1 + f$$

예를 들어, $0.11_{(2)} = 0.75$ 일 때, $M = 1.11_{(2)} = 1.75$ 라고 할 수 있다.

> **암시된 선행 1 표현**은 Normalized Values에서, 가수부 $M$이 항상 $1 \le M \lt 2$의 범위에 있을 수 있도록 지수부 $E$를 조정할 수 있기 때문에 가능한 기법이다. 즉, 선행 비트는 항상 1이 될 수 있기 때문에 생략할 수 있다.


![Standard Floating-Point Formats](./static//figure%202-31.png)

![Categories of Single-Precision, Floating-Point Values](./static//figure%202-32.png)

### Case 2: Denormalized Values(비정규화된 숫자)

지수 필드가 모두 0인 경우 지수부($E$)와 가수부($M$)은 다음을 만족한다.

$$\begin{align*}
&E = 1 - Bias \\ 
&M = f 
\end{align*}$$

즉, Normalized Values과 다르게, 암시된 선행 1이 없는 분수 필드의 값이 된다.

비정규화된 숫자는 다음의 두 가지 목적을 가진다.

- 숫자값 0을 표현할 수 있는 방법을 제공
  - Normalized Values는 항상 $M \ge 1$이어야 하므로, 0을 표현할 수 없다.
  - $+0.0 부동 소수점 표현은 부호 비트, 지수부, 가수부 모두 0을 나타내며, $M = f = 0$이 된다.
  - 만약 부호 비트가 1이고, 나머지 비트가 모두 0이라면 $-0.0$으로 표현되는데, 이는 IEEE에서 어떤 면에서는 다르게, 혹은 같게 간주된다.

- 비정규화된 숫자는, 0.0에 매우 가까운 숫자를 표현할 수 있는 방법을 제공한다.
  - **점진적 언더플로우**(Gradual UnderFlow, 정규화된 값 중 최소값 보다 더 작은 값을 나타낼 수 있도록 하는 기법)

### Case 3: Special Values(특수 값)

- 양의 무한대($+\infty$)
  - 지수 필드가 모두 $1$이고, 분수 필드가 모두 $0$인 경우
- 음의 무한대($-\infty$)
  - 지수 필드가 모두 $1$이고, 분수 필드가 모두 $0$이면서, 부호 비트가 $1$인경우
- NaN(Not a Number)
  - 지수 필드가 모두 $1$이고, 분수 필드가 $0$이 아닌 경우

무한대는 숫자의 범위를 넘어서는 값을 표현하는 경우, NaN은 실수로 표현할 수 없는 값을 결과를 나타내기 위해 사용한다.

## 실수 표현에 대한 예시

![Representable values for 6-bit floating-point format](./static/figure%202-33.PNG)

$1$ 비트의 부호부($s$), $3$ 비트의 지수부($exp$), $2$ 비트의 소수부($frac$)를 가진 가상의 $6$ 비트 형식에서 표현할 수 있는 값들의 집합을 위의 그림에서 확인할 수 있다.

표현할 수 있는 정규화된 값(Normalized Values)의 최대 크기는 ${\pm{14}}$ 이다.

- $6$ 비트의 가장 큰 정규화된 값
  
$$\begin{align*}
& 0 \space 110 \space 11_{(2)}, \\
& e = 6, \space E = 3, \space 2^{E} = 8 \\
& f = \frac{3}{4}, \space M = \frac{7}{4} \\
& 2^{E} \times M = 8 \times \frac{7}{4} = 14
\end{align*}$$
 
비정규화된 값(Denormalized Values)은 $-1.0$에서 $+1.0$ 사이에 밀집되어 있으며, 원점에 가까울수록 더 조밀하다.

![Example nonnegative values for 8-bit floating-point format](./static/figure%202-34.PNG)


위의 그림에서는 8비트의 부동 소수점 표현 방식을 보여주는데, 중요한 것은 위의 비트 표현을 부호 없는 정수(UnSigned)로 나타내더라도, 오름차순으로 나타난다는 것이다. 이는 IEEE 부동 소수점 표현이 정수 정렬 루틴을 사용하여 정렬할 수 있도록 설계되었기 때문이다.

단, 음수를 처리할 때는 약간의 어려움이 발생한다. 이는 음수가 선행 1을 가지고 있으며, 내림차순으로 나타나기 때문이다. 이는 부동 소수점 연산 없이도, 비교를 수행하여 극복할 수 있다.

![Examples of nonnegative floating-point numbers](./static/figure%202-35.PNG)

위의 그림은, 일부 중요한 단정도 및 배정도 부동 소수점 숫자의 표현 및 수치 값을 보여준다.

여기서, $1 - \epsilon$, $2 - \epsilon$은, 각각 다음을 나타낸다.
$$\begin{align*}
& 1 - \epsilon = 1 - 2^{-n} \\
& 2 - \epsilon = 2 - 2^{-n} \\
\end{align*}$$

## 부호 없는 정수를 실수로 표현하기

정수 $12,345$를 실수로 단계별로 변환해보자

1. 정수 값의 2진수 표현

$$ 12345 = 11000000111001_{(2)} $$

2. 정규화된 값으로 변환

$$\begin{align*} 
&1.1000000111001_{(2)} \times 2^{13} \\
&E = 13 \\
&M = 1000000111001_{(2)}
\end{align*}$$

3. IEEE 단정도 형식으로 인코딩

- 유효 숫자($M$) 필드 생성
  - 선행 1을 제거 한 후, 10 개의 0을 추가한다.
  - $10000001110010000000000_{(2)}$

- 지수 필드 생성
  - $ 13 + 127 = 140 $
  - $10001100_{(2)}$

- 부호 비트
  - 양수 이므로 $0$

4. 최종 부동 소수점 표현

$$ 01000110010000001110010000000000_{(2)} $$

이를 16진수로 나타낸다면 다음과 같다.
- 정수 12345
  - $0x3039$
- 단정도 부동 소수점 값 12345.0
  - $0x4640E400$


