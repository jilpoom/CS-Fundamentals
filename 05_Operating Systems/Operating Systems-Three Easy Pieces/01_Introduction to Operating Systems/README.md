# 운영 체제

>  이 책에서 우리가 답할 가장 중요한 질문은 "운영 체제가 어떻게 자원을 가상화하는가?" 이다. 가상화를 달성하기 위해 운영 체제가 구현하는 메커니즘과 정책, 그리고 어떻게 효율적으로 수행하는지, 이 때 필요한 자원은 무엇인지를 알아본다.


실행 중인 프로그램은 매우 간단한 일을 한다. 명령을 그저 실행할 뿐이다. 매초 수백만에서 수십억 번까지, 프로세서는 메모리에서 명령을 가져와, 해석하고 실행한다. 이 명령을 마친 뒤, 프로세서는 다음 명령으로 넘어가고, 그렇게 계속 반복하여 프로그램이 마침내 완료될 때까지 진행된다.

이렇게, 프로그램을 쉽게 실행해줄 수 있는 소프트웨어가 있다. 심지어 이 소프트웨어는 여러 프로그램을 동시에 실행하는 것처럼 보이게 할 수도 있다. 이를 Operating System(운영 체제)라고 한다.

운영 체제는 가상화(Virtualization)라는 기술을 써서, 프로세서, 메모리, 디스크와 같은 물리적 자원을 더 일반적이고 사용하기 쉬운 형태로 변환한다. 그래서 때때로 운영 체제를 가상 머신이라고 부르기도 한다.

또한, 사용자가 운영 체제의 기능(프로그램 실행, 메모리 할당, 파일 접근 등) 사용할 수 있는 몇 가지 인터페이스(API)를 제공하며, 실제로 응용 프로그램에서 사용할 수 있는 몇 백개의 시스템 호출(System Call)을 제공한다. 이를 표준 라이브러리(Standard Library)를 제공한다고 말한다.

마지막으로 가상화는 다수의 프로그램이 실될 수 있게 하여, CPU를 공유하게 하고, 많은 프로그램이 동시에 자신의 명령과 데이터를 접근할 수 있게 한다. 그래서 운영 체제를 자원 관리자(Resource Manager)라고도 한다. 운영 체제는 자원을 효율적이고 공정하게, 또는 다른 여러 가능한 목표를 염두에 두고 관리해야 한다. 이를 예제를 통해 확인해보자

## 가상 CPU

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <assert.h>
#include "common.h"

int main(int rgc, char *argv[])
{
    if (argc != 2) {
        fprintf(strerr, "usage: cpu <string>\n");
        exit(1);
    }

    char *str = argv[1];

    while(1) {
        Spin(1);
        printf("%s\n", str);
    }
    return 0;
}
```

위의 예제를 실행해보면, 그저 `Spin` 함수(시간을 확인하고)를 호출하고, 시간을 반복적으로 확인하여, 1초 동안 실행한 뒤에 반환한다. 또한 사용자가 전달한 문자열을 영원히 반복한다.

이를 단일 프로세서가 있는 시스템에서 컴파일한다고 가정하자. 그렇다면 다음과 같은 결과를 보게 된다.

```bash
$ gcc -o cpu cpu.c -Wall
$ ./cpu "A"
A
A
A
A
^C
$ 
```

이건 별로 흥미롭진 않다. 이와 비슷하게 동일한 프로그램의 여러 인스턴스를 실행해보자.

```bash
$ ./cpu A & ./cpu B & ./cpu C & ./cpu D &
[1] 7353
[2] 7354
[3] 7355
[4] 7356
A
B
D
C
A
B
D
C
A
```

프로세서가 하나밖에 없는데도, 네 개의 프로그램이 동시에 실행되는 것처럼 보인다. 이는 운영체제가 하드웨어의 도움을 받아 시스템이 매우 많은 가상 CPU를 가진 것처럼 보이게 한 것이다. 이처럼 하나 혹은 소수의 CPU를 매우 많은 CPU처럼 보이게 하여 많은 프로그램이 동시에 실행되는 것처럼 보이게 하는 것을 CPU 가상화라고 한다.

이제 질문 거리가 하나 생긴다. 두 프로그램을 특정 시간에 동시에 실행하고자 할 때, 어떤 프로그램이 먼저 실행되어야 하는가? 이는 운영 체제의 정책에 의해 달라지며, 이 정책은 운영 체제가 구현하는 기본 메커니즘을 배우며 알아 볼 수 있다.

## 가상 메모리

메모리는 단순히 바이트의 배열일 뿐이다. 메모리를 읽기 위해서는 데이터가 저장된 위치인 주소를 지정해야 한다. 또한, 메모리에 쓰기(업데이트)를 하기 위해서는 주어진 주소에 쓰여질 데이터를 지정하면 된다.

프로그램이 실행되는 동안 메모리에 지속적으로 접근하며, 모든 데이터 구조를 메모리에 유지하고, 로드(load)와 스토어(store) 또는 다른 메모리 접근 명령을 통해 데이터에 접근하게 된다. 또한 각 명령어도 메모리 위에 있으므로, 명령어를 가져올 때마다 메모리에 접근하게 된다.

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include "common.h"

int main(int argc, char *argv[]) {
    if (argc != 2) { 
	fprintf(stderr, "usage: mem <value>\n"); 
	exit(1); 
    }

    int *p; 
    p = malloc(sizeof(int));
    assert(p != NULL);
    
    printf("(%d) addr pointed to by p: %p\n", (int) getpid(), p);
    
    *p = atoi(argv[1]); // assign value to addr stored in p
    
    while (1) {
	    Spin(1);
        *p = *p + 1;
        printf("(%d) value of p: %d\n", getpid(), *p);
    }

    return 0;
}
```

```bash
$ ./mem 1
(2134) address pointed to by p: 0x200000
(2134) p: 1
(2134) p: 2
(2134) p: 3
(2134) p: 4
(2134) p: 5
```

먼저, 메모리를 할당한다. 그런 다음 할당된 메모리의 주소를 출력하고, 새로 할당된 메모리의 첫 번째 슬롯에 입력된 첫번째 문자열을 을 넣는다. 마지막으로 프로그램은 반복문에 들어가서, 포인터 `p`가 가리키는 주소의 값을 증가 시킨다. 또한, 출력할 때마다 실행중인 프로세스 식별자(PID) 또한 출력한다.



```
$ ./mem &; ./mem &
[1] 24113
[2] 24114
(24113) memory address of p: 00200000
(24114) memory address of p: 00200000
(24113) p: 1
(24114) p: 1
(24114) p: 2
(24113) p: 2
(24113) p: 3
(24114) p: 3
(24113) p: 4
(24114) p: 4
```
같은 프로그램을 여러 번 실행시키면, 하나의 같은 주소(00200000)에, 메모리를 할당 받지만, 각각의 프로그램이 독립적으로 주소의 값을 갱신하는 것을 볼 수 있다. 각 프로그램은 물리 메모리를 다른 프로그램과 공유하는 것이 아니라, 각자 자신의 메모리를 가지고 있는 것처럼 보인다.

이러한 현상을 메모리 가상화(Virtualizing Memory)라고 하며, 각 프로세스는 자신만의 가상 주소 공간(Virtual Address Space), 때로는 그냥 주소 공간(Address Space)를 갖는다. 운영 체제는 이 가상 주소 공간을 컴퓨터의 물리 메모리로 매핑한다. 즉, 하나의 프로그램이 수행하는 각종 메모리 연산은 다른 프로그램의 주소 공간에 영향을 주지 않는다.

