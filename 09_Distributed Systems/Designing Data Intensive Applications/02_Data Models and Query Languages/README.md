# 데이터 모델과 쿼리 언어

데이터 모델은 소프트웨어 개발에서 가장 중요한 부분을 차지한다. 데이터 모델은 소프트웨어 작성 방식 뿐만 아니라, 우리가 해결하려는 문제를 생각하는 방식에도 영향을 미치기 때문이다.

대부분의 애플리케이션은 하나의 데이터 모델 위에, 또 다른 데이터 모델을 층층이 쌓아 올리는 방식으로 구축된다. 각 층에 대한 가장 중요한 질문은, "이 층의 데이터 모델은 어떻게 다음 하위 층의 데이터 모델로 표현될 수 있는가?"이다.

1. 실제 세계
  - 실제 세계(사람, 조직, 상품, 행동, 금전 흐름, 센서...)를 객체나 데이터 구조, 데이터를 조작하는 API의 형태로 모델링
2. 범용 데이터 모델
  - JSON, XML, 관계형 데이터 베이스, 그래프 모델 등, 데이터의 구조를 표현하는 방법을 결정  
3. 데이터 조작
  - 범용 데이터 모델을 메모리, 디스크, 네트워크의 바이트 단위로 표현하는 방법을 결정
4. 물리적 모델
  - 바이트를 전기 전류, 빛의 펄스 등으로 표현

각 레이어는 깨끗한 데이터 모델을 제공하므로써 하위 레이어의 복잡성을 숨겨야한다(추상화). 이는 소프트웨어 개발에 참여하는 모든 이들을 효과적으로 협력할 수 있게한다.
범용 데이터 모델, 즉 데이터베이스의 결정에 따라, 소프트웨어가 할 수 있는 일이 결정되기 때문에, 이 선택은 매우 중요하다.

이 장에서는, 데이터 저장 및 쿼리를 위한 범용 데이터 모델을 살펴본다.
  - 관계형 모델
  - 문서(Document) 모델
  - 그래프(Graph) 기반 모델

## 관계형 모델 VS 문서 모델

오늘날 가장 잘 알려진 데이터 모델은 SQL 데이터 모델로 1970년 Edgar Codd가 제안한, 관계형 모델에 기반을 두고 있다.

관계형 모델
 - 테이블(관계)로 구성
 - 각 테이블은 순서 없는 튜플(행)의 모음이다.

관계형 데이터베이스의 뿌리는 1960년대와 70년대, 메인 프레임 컴퓨터에서 수행되던 비즈니스 데이터 처리에 있다. 주로 거래 처리(Transaction Processing, 판매, 은행 거래, 항공 예약, 재고 관리 등)와 일괄 처리(Batch Processing)를 위함이었다.

관계형 모델의 목표는 깔끔한 인터페이스 뒤에 복잡한 구현 세부 사항을 숨기는 것이 목표였다.

1970년부터 1980년대 초, 관계형 모델의 대안이 되기 위해 네트워크 모델, 객체 지향 모델이 등장했으나, 관계형 모델이 그들을 지배하게 되었다. 오늘날에도 여전히 온라인 출판, 토론, 소셜 네트워킹, 전자상거래, 게임 등 여러 다양한 분야에서 사용되고 있다.

### NoSQL의 탄생

2010년대, SQL의 지배에 대항하기 위한 NoSQL이 등장했다. 'NoSQL' 이라는 이름 조차, 비관계형 데이터베이스에 관한 밋업을 위한 트위터 해시 태그가 퍼진 것(#NoSQL)이며, 현재는 'Not Only SQL'로 재해석 되었다.

NoSQL 데이터베이스 채택의 이유
- 매우 큰 데이터셋 또는 매우 높은 쓰기 처리량을 포함하여, 관계형 데이터베이스가 쉽게 달성할 수 없는 확장성
- 상업용 데이터베이스 제품보다, 무료 및 오픈 소스 소프트웨어에 대한 선호
- 관계형 모델에서 지원하지 않는 특화된 질의
- 관계형 스키마의 제약에 대한 불만과 동적이고 풍부한 데이터 모델에 대한 요구

각각의 응용 프로그램은 각기 다른 요구사항을 가지고 있다. 즉, 이제 관계형 데이터 베이스와 함께 다양한 NoSQL이 사용되는 사례가 많아지고 있다. ([Polyglot Persistence](https://www.techtarget.com/searchapparchitecture/definition/polyglot-persistence))

### 객체-관계 불일치

오늘날, 대부분의 어플리케이션은 객체 지향 프로그래밍 언어로 이루어지나, SQL은 관계형 모델이므로, 애플리케이션 코드와 데이터 베이스 모델 사이에 어색한 변환 계층이 필요해졌다.([Impedance Mismatch](https://sungsoo.github.io/2013/08/21/impedance-mismatch.html))

ActiveRecord와 Hibernate 같은 객체-관계 매핑(ORM) 프레임워크는 이러한 변환 계층에 필요한 상용구 코드를 줄여주지만, 두 모델 간의 차이점을 완전히 숨길 수는 없었다.

![LinkedIn Profile Using A Relational Schema](./static/figure%202-1.PNG)

위의 그림은, 이력서(LinkedIn Profile)을 관계형 스키마로 표현하는 방법을 보여주며 다음과 같은 특징이 있다.

- `user_id`로 전체 프로필의 고유 식별자를 부여한다.
- `first_name`, `last_name`과 같은 필드는 사용자별로 고유하므로 `users` 테이블의 열로 나타낸다.
- `positions`, `education`, `contact_info`와 같은 일대다(1:N) 관계는 여러 가지 방법으로 표현할 수 있다.
  - 전통적인 SQL 모델(1999 이전)
    - 별도의 테이블을 생성하여, `users` 테이블의 외래키로 참조한다.
  - SQL 표준 버전
    - 단일 행 내에, 다중값(XML, JSON 등 구조화된 데이터)을 저장하고 해당 문서 내부에서 질의 및 인덱싱
    - Oracle, IBM DB2, MS SQL Server, PostgreSQL 등에서 지원
  - XML, JSON 등 구조화된 데이터로 인코딩하여, 데이터베이스의 텍스트 열에 저장 후, 애플리케이션이 그 구조와 내용을 해석

이력서와 같은, 데이터 구조는 대부분 독립적인 문서로 JSON 표현이 적합할 수 있다. MongoDB, RethinkDB, CouchDB, Espresso와 같은 문서 지향 데이터베이스가 이 데이터 모델을 지원한다.

```json
{
  "user_id": 251,
  "first_name": "Bill",
  "last_name": "Gates",
  "summary": "Co-chair of the Bill & Melinda Gates... Active blogger.",
  "region_id": "us:91",
  "industry_id": 131,
  "photo_url": "/p/7/000/253/05b/308dd6e.jpg",
  "positions": [
    {"job_title": "Co-chair", "organization": "Bill & Melinda Gates Foundation"},
    {"job_title": "Co-founder, Chairman", "organization": "Microsoft"}
  ],
  "education": [
    {"school_name": "Harvard University", "start": 1973, "end": 1975},
    {"school_name": "Lakeside School, Seattle", "start": null, "end": null}
  ],
  "contact_info": {
    "blog": "http://thegatesnotes.com",
    "twitter": "http://twitter.com/BillGates"
  }
}
```

관계형 예제에서, 프로필을 가져오려면 여러 쿼리를 수행(각 테이블을 `user_id`로 쿼리)해야 하거나, 복잡한 다중 `JOIN`을 수행해야 하지만, JSON 표현에서는 모든 관련 정보가 한 곳에 있어 하나의 쿼리로 충분하다.

사용자 프로필에서 사용자의 직책, 교육 이력, 연락처 정보로의 일대다 관계는 데이터에 트리 구조를 암시하며, JSON 표현은 이 트리 구조를 명시적으로 나타낸다.

![One-to-many relationships formaing a tree structure](./static/figure%202-2.PNG)

### 다대일 관계와 다대다 관계

Figure 2-1에서 `region_id`와 `industry_id`는 `Greater Seattle Area`와 같은 문자열이 아닌, ID 값으로 등록되어 있다. 물론, 사용자 인터페이스에서 지역과 산업을 입력하는 자유 텍스트 필드가 있다면, 이를 일반 텍스트 문자열로 저장하는 것이 합리적이나, 미리 표준화된 지역, 산업을 가지고 이를 사용자에게 선택하게 하는 것이 다음과 같은 많은 장점을 가진다.

- 프로필 전반(사용자들의 프로필)에서 일관된 스타일과 이름 유지
- 여러 도시가 같은 이름을 가질 때의 모호성 방지
- 업데이트 용이성
  - 이름은 데이터베이스 한 곳에만 저장되므로, 이를 수정하기만 하면 된다.
- 현지화(Localization) 지원
  - 사이트가 다른 언어로 변경될 때, 표준화된 목록을 현지화 할 수 있다.
- 더 나은 검색
  - 예를 들어, 워싱턴 주의 자선 사업가를 검색한다면 지역 목록에 시애틀이 워싱턴에 있다는 사실이 인코딩 될 수 있다. 즉 `Greater Seattle Area`라는 문자열 만으로 알 수 없는 매칭을 할 수 있다.


ID를 사용하는 이유는, 중복의 문제를 피하기 위해서이며, 이는 데이터 베이스 정규화의 핵심 아이디어이다. 언제든 변경될 수 있는 의미 있는 데이터에 고유 식별자를 부여함으로써, 데이터가 변경되더라도, 고유 식별자는 변경되지 않기 때문에 일관성을 유지할 수 있다.

데이터를 정규화 하기 위해서는, 다대일 관계(N:1, 여러 사람이 특정 한 지역에 살거나, 여러 사람이 특정 산업에 종사)가 필요하나, 이는 문서 모델엔 적합하지 않다. 관계형 데이터베이스는 `JOIN`을 통해 다른 테이블의 ID를 참조하여 이를 구조화할 수 있으나, 문서 모델에서는 `JOIN`이 필요 없으며, 있더라도, 지원이 약한 경우가 많다. 즉, 이는 애플리케이션 코드 내에서 이를 구현해야함을 의미한다.

초기에 문서 모델을 채택하여, 기존 애플리케이션 요구 사항에 적합한 기능을 구현하더라도, 시간이 지날수록 데이터는 상호 연결되는 경향이 높다. 예를 들어 다음과 같다.

- 프로필에, 조직과 학교를 엔티티로 사용하기

![Organization, Company Entity](./static/figure%202-3.PNG)

만약, 조직(사용자의 소속 회사)이나, 학교(소속 학교) 등을 단순 문자열 대신 엔티티(데이터 모델링에 사용되는 객체)로 변경한다면, 각각의 조직과 학교는 웹사이트 링크, 로고 등의 정보를 포함할 수 있다.

- 추천 기능

소속된 회사의 상사가 한 사용자를 추천하는 기능을 생각해보자. 추천은 추천받은 사용자의 이력서에 표시되며, 추천한 사용자의 이름, 프로필 사진도 함께 표시되어야 한다.

위의 새로운 기능은 다대다(N:N) 관계의 필요성을 보여주며, 대략적인 그림은 아래와 같다. 점선 사각형 내부의 데이터는 하나의 문서(Document)로 그룹화가 가능하지만, 그 이외의 참조는 조인이 필요한 경우이다.

![Recommend](./static/figure%202-4.PNG)


## 문서 데이터베이스 모델도 역사를 반복하는가?

이러한 문제는, 비단 오늘날의 문제만은 아니다. 다대다 관계와 JOIN이 가능한 관계형 데이터베이스와 달리, 문서 데이터베이스의 관계 표현 방식에 대한 논란은 과거에도 존재했다.

1970년대, 비즈니스 데이터베이스 중 가장 인기 있었던 IBM의 IMS(정보 관리 시스템)은, 계층 모델이라 불리는 간단한 데이터 모델을 가지고 있었는데 이것은 오늘날의 JSON 구조과 매우 유사하다. 이는 문서 모델과 마찬가지로, 일대다 관계에서는 강력했으나, 다대다 관계를 어렵게 만들고 조인 또한 지원하지 않았다. 즉 개발자는 다음과 같은 두 가지 선택 중 하나를 선택해야했다.

- 데이터 중복(비정규화)를 통해 다대다 관계를 표현
- 한 레코드에서 다른 레코드 참조를 애플리케이션 코드, 즉 수동으로 해결

이러한 계층 모델의 한계를 극복하기 위해 여러 해결책이 제시되었으며, 그 중 가장 주목할만한 관계형 모델과 네트워크 모델에 대해 알아보자.

### 네트워크 모델

네트워크 모델은 데이터 시스템 언어 회의(CODASYL)라는 위원회에 의해 표준화되었고, 여러 데이터베이스 공급업체에 의해 구현되었다. 이는 CODASYL 모델이라고 알려져 있다.

네트워크 모델의 특징은 다음과 같다.

- 계층 모델은 모든 레코드가 정확히 하나의 부모를 가지나, 네트워크 모델에서는 한 레코드가 여러 부모를 가질 수 있다. 즉, 다대일 및 다대다 관계를 표현할 수 있다.
- 레코드 간의 연결은 외래 키가 아닌, 포인터와 같은 방식으로 접근할 수 있었다. 즉, 레코드에 접근하는 유일한 방법은 루트 레코드에서 연결 체인을 따라가는 것이다.(Access Path)
- 네트워크 모델의 검색 방식은 연결 리스트와 비슷하다. 즉, Root부터 원하는 레코드를 찾을 때까지 하나씩 레코드를 살피는 것이다. 다대다 관계의 세상에서는 하나의 레코드에 접근하는 경로가 많기 때문에, 개발자는 이를 기억해야 했다.

네트워크 모델의 수동 접근 경로 선택 방식은, 1970년대의 매우 제한된 하드웨어 성능을 가장 효율적으로 사용할 수 있게 했으나, 데이터베이스의 쿼리 코드를 매우 복잡하게 만들었다. 접근 경로를 변경하더라도, 수많은 쿼리 코드를 수정하고, 새로운 접근 경로를 처리하도록 해야했다. 즉, 애플리케이션의 데이터 베이스 모델을 변경하는 것을 매우 어렵게 했다.

### 관계형 모델

반면, 관계형 모델은, 관계(테이블)를 단순히 튜플(행)의 집합으로 표현한다. 데이터를 살펴보기위해 복잡한 접근 경로, 중첩 구조를 따를 필요가 없으며, 임의의 조건에 맞는 행을 선택하기만 하면 된다.

또한, 특정 열을 키로 선택하고, 그에 맞추어 특정 행을 읽을 수 있다. 다른 테이블의 참조를 걱정하지 않고도 언제든 새 행을 삽입할 수 있다.

네트워크 모델과의 가장 큰 차이점은, 쿼리의 실행 순서를 개발자가 아닌, 쿼리 최적화기(Query Optimizer)가 자동으로 선택한다는 것이다. 즉, 개발자는 접근 경로를 생각할 필요가 거의 없다.

데이터를 새로운 방식으로 쿼리하려면, 단순히 새로운 인덱스를 선언하면 되고, 쿼리는 자동으로 가장 적합한 인덱스를 사용한다.

쿼리 최적화기는 매우 복잡하지만, 이를 한 번만 구축한다면 모든 애플리케이션이 그 혜택을 누릴 수 있다. 즉 장기적으로 관계형 모델이 승리할 수 있는 주요 원인이 되었다.

### 문서 모델과의 비교

문서 모델은 한 가지 측면에서는 계층 모델로 되돌아 갔다. 즉, 부모의 레코드에 중첩된 자식 레코드(일대다 관계)를 별도의 테이블이 아닌, 부모 레코드 내에 저장하는 방식이다.

그러나 다대일, 다대다를 표현하는 방식은 관계형 모델과 근본적으로 다르지 않다. 즉, 고유 식별자로 각 레코드를 참조하며, 이는 관계형 모델에서는 외래키, 문서 모델에서는 문서 참조라고 한다. 이 식별자는 읽기 시점에 조인 또는 후속 쿼리를 통해 해결되며, 이 점에서 네트워크 모델(CODASYL)과 다르다고 볼 수 있다.

## 오늘날의 관계형 데이터베이스와 문서 데이터 베이스 비교

문서 데이터 모델을 지지하는 주요 이유는 스키마 유연성, 지역성으로 인한 성능 향상, 그리고 일부 애플리케이션에서는 애플리케이션이 사용하는 데이터 구조와 더 가깝다. 이에 반해 관계형 모델은 조인, 다대일 및 다대다 관계에 대한 더 나은 지원을 제공한다.

### 어떤 모델이 더 간단한 애플리케이션 코드를 유도하는가

- 문서 데이터베이스
  - 일대다 관계의 애플리케이션 데이터를 한 번에 로드하는 경우에 매우 적합하다.(시계열 데이터, 로그 등등)
  - 문서 내의 중첩 항목을 직접 참조할 수 없으며, `사용자.직책[1]`과 같이 계층 모델의 접근 경로 방식과 유사한 방식으로 참조해야 한다. 하지만 너무 깊지만 않으면 크게 문제되지 않는다.
  - 다대다 관계의 데이터의 경우 비정규화를 통해 해결할 수 있으나, 일관성을 위한 추가 작업이 필요하다.
  - 여러 번의 데이터 베이스 요청을 통해 조인과 유사하게 사용할 수 있으나, 일반적으로 데이터 베이스 내부의 전문화된 조인보다 느리다.

- 관계형 데이터베이스
  - 다대다, 다대일 관계의 애플리케이션 데이터에 적합하다.
  - 관계형 데이터베이스의 문서 분해 기법은 문서와 같은 구조를 여러 테이블로 분할하는 방식으로, 이는 번거로운 스키마와 복잡한 애플리케이션 코드를 초래한다.

어떤 데이터 모델이 더 간단한 애플리케이션 코드를 유도하는지는 일반적으로 말하기 어렵다. 데이터가 상호 연결된 경우, 문서 모델은 어색하고, 관계형 모델은 수용 가능하며, 그래프 모델이 가장 자연스럽다.

### 문서 모델의 스키마 유연성

문서 모델과 관계형 모델의 JSON 지원은 하나의 스키마를 강제하지 않는다. 이는 문서에 임의의 키와 값을 추가할 수 있음을 뜻하며, 클라이언트는 문서에 어떤 필드가 포함되어 있는지 보장받지 못한다는 것이다.

문서 데이터베이스는 스키마가 없다(Schemaless)라고 불리지만, 이는 오해의 소지가 있다. 데이터를 읽는 코드는 보통 어떤 구조를 가정한다. 즉 **읽기 시, 스키마(Schema-on-read)** 의 방식으로 존재한다. 이는 관계형 데이터베이스의 **쓰기 시, 스키마(Schema-on-write)** 방식과 대조되는 특징이다. 

관계형 데이터베이스는 쓰기 시, 스키마를 정적 검증(컴파일 타입 검사와 유사)하며, 문서형 데이터베이스는 읽기 시, 스키마를 동적 검증(런타임 타입 검사와 유사)하는 방식이다.

예를 들어, 각 사용자의 전체 이름을 하나의 필드에 저장하다가, 이를 `first_name`, 즉 성과 이름으로 분리하고 싶다고 가정하자. 각각의 데이터베이스에 따른 구현 방법은 다음과 같다.

- 문서형 데이터베이스
  - 단순히, 새로운 필드를 추가하고, 만약 이전 문서를 읽어야할 경우, 다음과 같이 애플리케이션 코드를 변경한다.
```javascript
if (user && user.name && !user.first_name) {
  // 2013년 12월 8일 이전에 작성된 문서에는 first_name이 없습니다.
  user.first_name = user.name.split(' ')[0];
}
```

- 관계형 데이터베이스
  - 다음과 같이 마이그레이션을 수행한다.
```sql
ALTER TABLE users ADD COLUMN first_name text;
UPDATE users SET first_name = split_part(name, ' ', 1); -- PostgreSQL
UPDATE users SET first_name = substring_index(name, ' ', 1); -- MySQL
```

스키마 변경은 느리고, 다운 타임을 요구하는 것으로 악명이 높으나, 모든 경우에 그런 것은 아니다. 대부분의 관계형 데이터베이스는 `ALTER TABLE`을 단 몇 밀리초 내에 실행한다.(MySQL은 예외적으로 전체 테이블을 복사한다.) 

 단, 큰 테이블의 UPDATE 구문은 모든 데이터베이스에서 느릴 가능성이 크다. 이를 해결하기 위해, `first_name` 필드의 기본값을 `NULL`로 설정하고 애플리케이션 코드에서 이를 채울 수 있다.

읽기 시, 스키마 접근 방식은 일관되지 않는 구조를 피할 수 없을 때, 채택하는 것이 좋다.

- 다양한 종류의 객체가 있으며, 이를 한 테이블에 넣는 것이 현실적이지 않을 때
- 데이터의 구조가 외부에서 결정되며, 언제든 구조가 변경될 가능성이 있을 때

위의 상황에서는 스키마의 강제성이 방해가 될 수 있으며, 문서형 데이터베이스에 적합할 수 있다.

### 데이터 조회의 지역성(로컬리티)

애플리케이션이 전체 문서에 자주 접근해야 하는 경우(웹페이지 랜더링), 이러한 저장 로컬리티는 성능상의 이점을 제공한다.

로컬리티의 이점은 문서의 큰 부분을 동시에 필요로 할 때만 적용된다. 문서의 일부에 접근하기 위해, 전체를 로드해야 한다면, 성능 저하가 발생한다. 또한 문서를 업데이트 해야하는 경우, 보통의 경우 전체 문서를 다시 써야 하며, 문서의 인코딩된 크기를 변경하지 않는 수정만이 쉽게 수행될 수 있다. 즉, 문서를 비교적 작게 유지하고, 문서 크기를 증가시키는 쓰기는 피하는 것이 일반적으로 권장된다.

### 문서형 데이터베이스와 관계형 데이터 베이스의 융합

관계형 데이터베이스에서 JSON과 같은 문서형 데이터 타입 지원이 점차 늘고 있다. 이는 웹 API에서 JSON의 인기가 높아지며, 다른 관계형 데이터베이스들도 JSON을 지원할 가능성이 커졌다는 의미다.

문서 데이터베이스 측면에서는 RethinkDB가 쿼리 언어에서 관계형 조인과 유사한 기능을 지원하며, 일부 MongoDB 드라이버는 데이터베이스 참조를 자동으로 해결하여(사실상 클라이언트 측에서 조인을 수행하지만, 이는 추가적인 네트워크 왕복이 필요하고 최적화가 덜 되어 데이터베이스에서 수행되는 조인보다 느릴 가능성이 있다.) 관계형 조인과 유사한 작업을 수행한다.

관계형 데이터베이스와 문서 데이터베이스는 시간이 지남에 따라 점차 유사해지고 있으며, 이는 긍정적인 현상으로 볼 수 있다. 만약 하나의 데이터베이스가 문서와 같은 처리를 하면서도 관게형 쿼리를 수행할 수 있다면, 요구사항에 가장 적합한 기능 조합을 사용할 수 있다.([MySQL JSON vs. TEXT](https://medium.com/daangn/json-vs-text-c2c1448b8b1f))


## 데이터를 위한 쿼리 언어

대부분의 프로그래밍 언어는 명령형이다. 다음은 동물의 종 목록에서 상어만을 반환하는 코드이다.

```js
function getSharks() {
  var sharks = [];
  for (var i = 0; i < animals.length; i++) {
    if (animals[i].family === "Sharks") {
      sharks.push(animals[i]);
    }
  }
  return sharks;
}
```

관계 대수에서는 다음과 같이 작성한다.

$$sharks = \sigma_{family = sharks}(animal)$$

$\sigma$는 선택 연산자로, 조건에 맞는 동물만을 반환한다. 즉 `family = sharks`인 동물들만을 반환한다. SQL은 이러한 관계 대수(Relational Algebra)의 구조를 밀접하게 따랐다.

```SQL
SELECT * FROM animals WHERE family = 'Sharks';
```

SQL이나, 관계 대수와 같은 선언형 쿼리 언어(Declarative Query Language)는 원하는 데이터의 패턴(정렬, 그룹화, 집계 등)을 지정하며, 그 목표를 달성하는 방법은 지정하지 않는다. 이는 쿼리 옵티마이저가 어떤 인덱스를 사용할지, 어떤 조인을 사용할지 그리고 각 쿼리 부분을 어떤 순서로 실행할지 결정한다. 선언형 쿼리 언어는 명령형 API보다 간결하고 작업이 쉽다.

중요한 것은 엔진의 구현 세부 사항을 숨겨 데이터 베이스 시스템에 성능 개선을 도입해도 쿼리문 자체에는 아무 영향이 없도록 한다는 점이다. 명령형 코드에서는 동물 목록의 특정 순서가 이미 코드로 표현이 되어있다. 만약, 데이터베이스가 백그라운드에서 사용하지 않는 디스크 공간을 회수하려 할 때, 레코드를 이동시켜 동물의 순서를 변경해야 한다면, 이러한 명령형 코드에서는 데이터베이스가 코드가 순서에 의존하는지 확신할 방법이 없다. 하지만 선언형 코드에서는 특정한 순서를 보장하기 않기 때문에 순서가 변경이되어도 상관이 없다.

또한, 선언형 언어는 병렬 실행에 적합하다. 명령형 코드는 특정 순서대로 수행해야 하는 지시 사항을 지정하기 때문에, 여러 코어와 기계에서 병렬화 되기 쉽지 않다. 그러나 선언형 언어는 결과의 패턴만 지정하고, 결과를 결정하는 알고리즘은 지정하지 않기 때문에 병렬 실행에 더 적합하다.


### 웹에서의 선언적 쿼리

선언형 쿼리의 장점은 데이터베이스에만 국한되지 않는다. 만약 웹사이트에서 네비게이션 항목에 `Sharks`를 선택하여 표시하고 싶다면 다음과 같이 작성한다.

```html
<ul>
  <li class="selected">
    <p>Sharks</p>
    <ul>
      <li>Great White Shark</li>
      <li>Tiger Shark</li>
      <li>Hammerhead Shark</li>
    </ul>
  </li>
  <li>
    <p>Whales</p>
    <ul>
      <li>Blue Whale</li>
      <li>Humpback Whale</li>
      <li>Fin Whale</li>
    </ul>
  </li>
</ul>
```

만약 선택된 페이지의 제목을 파란색으로 강조하고 싶다면 다음과 같이 CSS 선언형 언어를 사용할 수 있다.

```css
li.selected > p {
  background-color: blue;
}
```

만약 명령적 접근 방식을 사용해야한다면, Javscript의 DOM API를 사용해 다음과 같이 작성할 수 있다.

```js
var liElements = document.getElementsByTagName("li");
for (var i = 0; i < liElements.length; i++) {
  if (liElements[i].className === "selected") {
    var children = liElements[i].childNodes;
    for (var j = 0; j < children.length; j++) {
      var child = children[j];
      if (child.nodeType === Node.ELEMENT_NODE && child.tagName === "P") {
        child.setAttribute("style", "background-color: blue");
      }
    }
  }
}
```

허나, 이런 방식은 코드가 매우 복잡해지고, 이해하기 어려워진다. 뿐만 아니라 다음과 같은 심각한 문제가 있다.

- 선택된 클래스가 제거(사용자가 다른 페이지를 클릭)하는 경우, 파란색 배경이 제거되지 않는다.
  - 선언형 CSS와 같은 경우, 규칙이 더이상 적용되지 않으면 이를 자동으로 감지해 파란색 배경을 제거한다.
- `document.getElementsByClassName("selected")`와 같은 API를 사용하고 싶다면, 성능 향상을 위해서 코드를 다시 작성해야 한다.
  - CSS는 호환성을 건드리지 않고 성능을 향상시킬 수 있다.

마찬가지로 데이터베이스에서도 SQL과 같은 선언적 쿼리 언어가 명령형 쿼리 API보다 훨씬 더 우수한 것으로 판명되었다.