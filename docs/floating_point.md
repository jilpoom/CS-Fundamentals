# 부동 소수점

부동 소수점이란, 다음과 같은 형태의 유리수를 인코딩하는 방법이다.

$$V = x \times 2^{y}$$

이는 매우 큰 숫자($V > 0$)와, 작은 숫자($V < 0$), 그리고 실수 연산의 근사치로 사용된다.

1980년대 이후, [IEEE 754](https://ko.wikipedia.org/wiki/IEEE_754) 표준이 부동 소수점 연산의 표준화를 이루어 갔으며, 현재 서로 다른 시스템 간의 호환성을 보장하고 수치적 안정성을 향상시키는데 기여하고 있다.

이 섹션에서는 IEEE 754에서 정의된 부동 소수점 연산 표준을 살펴보며, 숫자가 형식에서 정확하게 표현될 수 없을 때, 발생하는 반올림 문제, 부동 소수점 간의 연산 또한 살펴본다.

## 소수점을 가진 숫자를 이진수로 표현

10의 양의 거듭제곱으로 소수를 가진 실수를 나타낸다면 다음과 같다.

$$12.3410 = 1 \times 10^1 + 2 \times 10^0 + 3 \times 10^{-1} + 4 \times 10^{-2} = 12 \frac {34}{100}$$

이를 이진 숫자로 나타낸다면 소수부를 가진 실수 $b$를 다음과 같이 정의할 수 있다.

$$b = \sum^{m}_{i = -n} 2 ^i \times b_i$$

아래의 식에서 $.$은 이진 소수점을 나타낸다.

$$101.11_{(2)} = 1 \times 2^2 + 0 \times 2 ^1 + 1 \times 2^{0} + 1 \times 2^{-1} + 1 \times 2^{-2} = 4 + 0 + 1 + \frac {1}{2} + \frac {1}{4} = 5 \frac {3}{4}$$

위의 표현 방식은 부동 소수점 숫자를 이해하고 구현하는데 중요한 역할을 한다.

![부동 소수점의 이진 표현](./_images/computer_system/04/figure%202-30.PNG)

### 소수의 이진 표현의 한계

$$b = \sum^{m}_{i = -n} 2 ^i \times b_i$$

위의 방정식에서 알 수 있듯, 소수의 이진 표현은 $x \times 2^{-n}$의 형태의 소수만을 정확하게 나타낼 수 있으며, $\frac {1}{3}$, $\frac {1}{5}$와 같은 소수는 근사치로만 표현할 수 있다.

## IEEE 부동 소수점 표현

IEEE 부동소수점 표준은 숫자를 다음의 형태로 표현한다.

$$V = (-1)^s \times M \times 2^E$$

- $s$: 숫자가 음수($s = 1$) 혹은 양수($s = 0$)인지 결정. 숫자 값 0에 대한 부호 비트 해석은 특별한 경우로 처리된다.
- $M$: 가수, $1$과 $2$ 사이 혹은 $0$과 $1$ 사이의 소수 이진수
- $E$: 2의 지수, 가중치

즉, 부동 소수점 숫자의 비트 표현은 인코딩을 위해 3 가지의 필드로 나누어진다.

- 부호 필드: 부호 비트 $s$를 인코딩
- 지수 필드: $k$ 개의 비트($exp = e_{k-1}...e_1e_0$)로 지수 $E$를 인코딩
- 가수 필드: $n$ 개의 비트($frac = f_{n-1}...f_1f_0$)로 가수 $M$을 인코딩. 단, 인코딩된 값은 지수 필드가 0인지 아닌지에 따라 달라진다.

예를 들어 `float` 타입(단일 정밀도 부동 소수점 형식)에서 필드 $s$, $exp$, $frac$은 각각 $1$, $8$, $23$ 비트이며, 이는 총 $32$ 비트 표현을 제공한다. 마찬가지로, `double` 타입(이중 정밀도 부동 소수점 형식)은 각각 $1$, $11$, $52$ 비트 이며, 이는 총 $64$비트 표현을 제공한다.

### Case 1: Normalized Values(정규화된 숫자)

일반적인 경우, 지수($exp$) 비트 패턴이 모두 0(모든 비트가 0) 혹은 1이 아닌 경우(`float` 255, `double` 2047) 발생한다. 

이 경우의 지수 필드는, **편향(바이어스)된 형태로 표현된 부호 있는 정수로 해석**된다.

$$\begin{align*} &E = e - Bias \\
&e = [e_{k-1}...e_1e_0]_{(2)} \\
&Bias = 2^{k - 1} - 1 
\end{align*}$$


또한, 분수(소수) 필드는 분수값 $f$를 나타내며 다음과 같은 식을 만족한다.

$$\begin{align*}
&0 \le f \lt 1, \\
&f = [0.f_{n-1}f_{n-2}...f_{1}f_{0}]_{(2)} 
\end{align*}$$

**암시된 선행 1 표현**이라는 기법으로, 가수부 $M$은 다음과 같이 선언된다.

$$M = 1 + f$$

예를 들어, $0.11_{(2)} = 0.75$ 일 때, $M = 1.11_{(2)} = 1.75$ 라고 할 수 있다.

> **암시된 선행 1 표현**은 Normalized Values에서, 가수부 $M$이 항상 $1 \le M \lt 2$의 범위에 있을 수 있도록 지수부 $E$를 조정할 수 있기 때문에 가능한 기법이다. 즉, 선행 비트는 항상 1이 될 수 있기 때문에 생략할 수 있다.


![Standard Floating-Point Format](_images/computer_system/04//figure%202-31.png)

![Categories of Single-Precision, Floating-Point Value](_images/computer_system/04//figure%202-32.png)

### Case 2: Denormalized Values(비정규화된 숫자)

지수 필드가 모두 0인 경우 지수부($E$)와 가수부($M$)은 다음을 만족한다.

$$\begin{align*}
&E = 1 - Bias \\ 
&M = f 
\end{align*}$$

즉, Normalized Values과 다르게, 암시된 선행 1이 없는 분수 필드의 값이 된다.

비정규화된 숫자는 다음의 두 가지 목적을 가진다.

- 숫자값 0을 표현할 수 있는 방법을 제공
  - Normalized Values는 항상 $M \ge 1$이어야 하므로, 0을 표현할 수 없다.
  - $+0.0$ 부동 소수점 표현은 부호 비트, 지수부, 가수부 모두 0을 나타내며, $M = f = 0$이 된다.
  - 만약 부호 비트가 1이고, 나머지 비트가 모두 0이라면 $-0.0$으로 표현되는데, 이는 IEEE에서 어떤 면에서는 다르게, 혹은 같게 간주된다.

- 비정규화된 숫자는, 0.0에 매우 가까운 숫자를 표현할 수 있는 방법을 제공한다.
  - **점진적 언더플로우**(Gradual UnderFlow, 정규화된 값 중 최소값 보다 더 작은 값을 나타낼 수 있도록 하는 기법)

### Case 3: Special Values(특수 값)

- 양의 무한대($+\infty$)
  - 지수 필드가 모두 $1$이고, 분수 필드가 모두 $0$인 경우
- 음의 무한대($-\infty$)
  - 지수 필드가 모두 $1$이고, 분수 필드가 모두 $0$이면서, 부호 비트가 $1$인경우
- NaN(Not a Number)
  - 지수 필드가 모두 $1$이고, 분수 필드가 $0$이 아닌 경우

무한대는 숫자의 범위를 넘어서는 값을 표현하는 경우, NaN은 실수로 표현할 수 없는 값을 결과를 나타내기 위해 사용한다.

## 실수 표현에 대한 예시

![Representable values for 6-bit floating-point format](./_images/computer_system/04/figure%202-33.PNG)

$1$ 비트의 부호부($s$), $3$ 비트의 지수부($exp$), $2$ 비트의 소수부($frac$)를 가진 가상의 $6$ 비트 형식에서 표현할 수 있는 값들의 집합을 위의 그림에서 확인할 수 있다.

표현할 수 있는 정규화된 값(Normalized Values)의 최대 크기는 ${\pm{14}}$ 이다.

- $6$ 비트의 가장 큰 정규화된 값
  
$$\begin{align*}
& 0 \space 110 \space 11_{(2)}, \\
& e = 6, \space E = 3, \space 2^{E} = 8 \\
& f = \frac{3}{4}, \space M = \frac{7}{4} \\
& 2^{E} \times M = 8 \times \frac{7}{4} = 14
\end{align*}$$
 
비정규화된 값(Denormalized Values)은 $-1.0$에서 $+1.0$ 사이에 밀집되어 있으며, 원점에 가까울수록 더 조밀하다.

![Example nonnegative values for 8-bit floating-point format](./_images/computer_system/04/figure%202-34.PNG)


위의 그림에서는 8비트의 부동 소수점 표현 방식을 보여주는데, 중요한 것은 위의 비트 표현을 부호 없는 정수(UnSigned)로 나타내더라도, 오름차순으로 나타난다는 것이다. 이는 IEEE 부동 소수점 표현이 정수 정렬 루틴을 사용하여 정렬할 수 있도록 설계되었기 때문이다.

단, 음수를 처리할 때는 약간의 어려움이 발생한다. 이는 음수가 선행 1을 가지고 있으며, 내림차순으로 나타나기 때문이다. 이는 부동 소수점 연산 없이도, 비교를 수행하여 극복할 수 있다.

![Examples of nonnegative floating-point number](_images/computer_system/04/figure%202-35.PNG)

위의 그림은, 일부 중요한 단정도 및 배정도 부동 소수점 숫자의 표현 및 수치 값을 보여준다.

여기서, $1 - \epsilon$, $2 - \epsilon$은, 각각 다음을 나타낸다.

$$\begin{align*}
& 1 - \epsilon = 1 - 2^{-n} \\
& 2 - \epsilon = 2 - 2^{-n} \\
\end{align*}$$

## 부호 없는 정수를 실수로 표현하기

정수 $12,345$를 실수로 단계별로 변환해보자

1. 정수 값의 2진수 표현

$$ 12345 = 11000000111001_{(2)} $$

2. 정규화된 값으로 변환

$$\begin{align*} 
&1.1000000111001_{(2)} \times 2^{13} \\
&E = 13 \\
&M = 1000000111001_{(2)}
\end{align*}$$

3. IEEE 단정도 형식으로 인코딩

- 유효 숫자($M$) 필드 생성
  - 선행 1을 제거 한 후, 10 개의 0을 추가한다.
  - $10000001110010000000000_{(2)}$

- 지수 필드 생성
  - $ 13 + 127 = 140 $
  - $10001100_{(2)}$

- 부호 비트
  - 양수 이므로 $0$

4. 최종 부동 소수점 표현

$$ 01000110010000001110010000000000_{(2)} $$

이를 16진수로 나타낸다면 다음과 같다.
- 정수 12345
  - $0x3039$
- 단정도 부동 소수점 값 12345.0
  - $0x4640E400$


## 반올림

부동 소수점 산술은 실수 산술을 근사화할 수밖에 없으므로, 표현 범위와 정밀도가 제한되어 있다. 따라서, 주어진 값 $x$에 대해 원하는 부동소수점 형식에서 가장 가까운 값을 찾는 반올림 방식이 필요하다.

중요한 문제는, 두 가능성(올림과 내림) 사이에 정확히 중간에 위치한 값을 어느 방향으로 반올림할지 정의하는 것이다. 또는 값 $x$에 대해 $x$가 두 가능성 사이에 위치하도록 보장할 수 있는 표현 가능한 값 $x-$와 $x+$를 결정하는 것이다.

IEEE 부동 소수점 방식은 네 가지의 반올림 모드를 정의한다.

![Illustration of rounding modes for dollar rounding](_images/computer_system/04/figure%202-36.PNG)


Round-to-even
-  Round-to-even 모드는, 가장 가까운 값을 찾으려고 시도한다, 
- 단, 정확한 중간값인 경우, 반올림 방향을 결정하는 것이 문제가 되는데, Round-to-even 모드는 가장 작은 유효 자릿수가 짝수가 되도록 반올림하는 규칙을 채택했다. - 즉, $1.50, $2.50 모두 짝수인 $2를 향해 반올림 된다.
- 이러한 방식은, 통계적 편향을 방지하기 위함이며, 이 모드를 사용하면 약 50%는 올림하고, 약 50%는 내림을 하게 된다.

Round-toward-zero
- 양수는 내림하고, 음수는 올림하여 값을 반올림한다.
- 즉, 항상 $|\hat{x}| \le |x|$를 만족하는 $|\hat{x}|$를 제공한다.

Round-down
- 양수와 음수 모두를 내림하여 반올림한다.
- $x- \le x$를 만족하는 $x-$를 제공한다.

Round-up
- 양수와 음수 모두를 올림하여 반올림한다.
- $x \le x+$를 만족하는 $x+$를 제공한다.

각 반올림 모드는 그 자체로 특정 수치적 응용 분야에서 사용되며, 각각 장단점이 있다.

Round-to-even으로 이진 소수점 수에 대해 반올림을 적용해야할 때, 가장 작은 유효 비트의 값이 $0$일 때, 짝수, $1$일 떄 홀수로 간주한다.

아래의 비트 패턴을 가진 부동 소수점의 이진 표현은 두 가능한 결과 사이의 중간값을 나타낸다.

$$XX...X.YY...Y100...$$

예를 들어, 다음과 같이 표현할 수 있다.
- $10.00011_{(2)}$(2.332)를 가장 가까운 $\frac{1}{4}$로 반올림 한다면, $10.00_{(2)}$(2.25)로 내림 처리 된다.
- $10.00110_{(2)}$(2.3125)를 가장 가까운 $\frac{1}{4}$로 반올림 한다면, $10.01_{(2)}$(2.75)로 올림 처리 된다.
- 만약, $10.11100_{(2)}$(2.875)와 같은 중간값을 반올림 한다면, $11.00_{(2)}$(3.0)으로 올림 처리 된다.
- 또한, $10.10100_{(2)}$(2.627)와 같은 중간값을 반올림 하면, $10.10_{(2)}$(2.5)로 내림 처리 된다.

즉, Round-to-even 모드는 이진 소수점 수에도 적용 될 수 있으며, 특히 중간값을 처리할 때, 가장 작은 유효 비트가 0이 되도록 한다.

## 부동 소수점 연산

IEEE 표준은 덧셈이나 곱셈과 같은 산술 연산의 결과를 결정하는 간단한 규칙을 명시한다. 부동 소수점 $x$, $y$를 실수로 보고, 연산을 수행할 때, 계산은 실수 연산의 정확한 결과에 반올림을 적용한 결과인 Round($x \odot y$)을 제공해야 한다.

실제로 정확한 계산을 수행하지 않고도, 올바르게 반올림 결과를 보여주기 위한 트릭이 있다. 또한, 정수의 계산법과 다르게, 하드웨어 혹은 소프트웨어의 구현과 독립적이다. 즉, 실제로 어떻게 구현되어 있는지는 고려하지 않고도 추상적인 수학적 특성을 조사할 수있다. 

우선, $\infty$, $\text{-}0$, $NaN$과 같은 특수 값의 정의를 미리 정한다.
  - E.G.) $1/-0$ = $-\infty$

### 아벨 군과 부동 소수점 덧셈 비교

이전에, 정수의 덧셈, 즉 부호 없는 덧셈(Unsigned Addition)과 이진수 보수법(Two's Complement)는 [아벨 군](https://ko.wikipedia.org/wiki/%EC%95%84%EB%B2%A8_%EA%B5%B0)을 형성(교환 법칙이 성립)한다고 배웠다. 실수에 대한 덧셈 또한 이를 만족하지만, 반올림이 이 성질에 미치는 영향을 고려해야한다.

$x + ^fy$이라는 연산을 $\text{Round(x + y)}$라고 할 때, 다음의 교환 법칙을 만족한다.
  - 단, 실제로 결과가 유한한 수라고 하더라도, 오버플로우로 인해, 무한대를 반환할 수 있다.

$$ x + ^fy = ^fy + x $$

그러나, 아벨 군의 특성인 결합 법칙은 성립하지 않는다. 예를 들어, 다음과 같은 상황은, $3.14$가 반올림 오류로 인해 사라진다.

$$ (3.14 + 1e10) - 1e10 = 0.0 $$

반면에, 다음은 $3.14$가 사라지지 않는다.

$$ 3.14 + (1e10 - 1e10) = 3.14 $$

실수의 덧셈은 아벨 군에서와 같이 역원을 가진다. 예를 들어, 다음과 같다.

$$ x + ^f-x = 0 $$

그러나, 무한대($\infty$) 혹은 $NaN$과 같은 경우는 예외적으로 처리된다.

$$ +\infty - \infty = NaN $$

$$ NaN + ^fx = NaN $$

이렇게, 결합 법칙이 성립하지 않는다는 특성은 컴파일러 작성자에게 매우 중요한 의미를 지닌다.

아래의 코드를 컴파일러에서 최적화하려고 한다.

```c
x = a + b + c;
y = b + c + d;
```

다음과 같이, 부동 소수점 덧셈 하나를 절약하고 싶다면, 다음과 같이 할 수 있다.

```c
t = b + c;
x = a + t;
y = t + d;
```

그러나, 덧셈 연산의 결합이 달라지게 되므로 원래 계산된 `x`와 다른 값을 얻게 될 수 있다. 이러한 문제로 인해, 컴파일러는 기능에 조금이라도 영향을 미치게 되는 경우 최적화를 피하게 된다.

### 부동 소수점 덧셈의 단조성(Monotonicity)

반면, 부동 소수점 덧셈은 단조성(monotonicity)을 만족한다. 즉, 다음이 성립한다.

- $a \ge b$, 일 때, $x + a \ge x + b$가 $NaN$이 아닌 모든 $a$, $b$, $x$에 성립한다.
  - 어떤 값이, 다른 값보다 크거나 같다면, 그 값에 같은 수를 더했을 때도 그 관계가 유지된다.

이러한 특성은, 정수의 부호 없는 덧셈이나, 이진수 보수법을 이용한 덧셈에서는 성립하지 않는다.


### 부동소수점 곱셈

다음과 같이 부동 소수점 곱셈을 정의한다.

$$ x * ^fy = Round(x \times y) $$

부동 소수점 곱셈은 다음과 같은 성질을 가진다.

- 곱셈에 대해 닫혀있다.
  - 부동 소수점을 곱한 결과도, 여전히 부동 소수점이다.
  - 단, 무한대와 $NaN$은 예외로 처리된다.
- 교환 법칙을 만족하나, 결합 법칙을 만족하지 않는다.
- 곱셈의 항등원은 1.0이다.
  - 항등원이란 어떤 실수 $x$에 대해 그 숫자를 변하지 않도록 곱할 수 있는 값을 의미한다.
- 덧셈에 대한 분배 법칙을 만족하지 않는다.
  - $1e20 \times (1e20 - 1e20) = 0.0$ 이지만, $1e20 \times 1e20 - 1e20 \times 1e20$은 $NaN$으로 계산된다.
- 단조성을 만족한다.

이렇게, 결합법칙과 분배 법칙의 결여는 과학 계산 프로그래머 혹은 컴파일러 작성자에게 심각한 문제를 야기할 수 있다. 


